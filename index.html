<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Plants vs. Zombies ‚Äî Endless Canvas</title>
<style>
  :root {
    --bg: #153b2d;
    --lawn1: #1a694f;
    --lawn2: #1f7559;
    --gridline: #0e362a;
    --panel: #0f2620;
    --panel-border: #123c2f;
    --white: #edf7f3;
    --accent: #ffd54f;
    --danger: #ff5c5c;
  }
  html, body {
    height: 100%; margin: 0;
    background: linear-gradient(180deg, #0e2019, #164233);
    color: var(--white);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  }
  .wrap {
    display: grid; grid-template-columns: minmax(240px, 300px) 1fr;
    gap: 12px; padding: 12px; height: 100%; box-sizing: border-box;
  }
  .sidebar {
    background: rgba(15,38,32,0.9); border: 1px solid var(--panel-border);
    border-radius: 10px; padding: 12px; display: grid;
    grid-template-rows: auto auto 1fr auto auto; gap: 10px; overflow: auto;
  }
  .title { font-weight: 700; letter-spacing: .5px; }
  .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .stat { background:#0c1e19; border:1px solid #113429; border-radius:8px; padding:8px; font-size:14px; }
  .buttons { display: grid; gap: 8px; }
  .btn {
    display: grid; grid-template-columns: 36px 1fr auto; align-items: center; gap: 8px;
    background:#13382c; border:1px solid #195141; border-radius:8px; padding:8px; cursor:pointer; user-select:none;
  }
  .btn:hover { filter: brightness(1.08); }
  .btn.active { outline: 2px solid var(--accent); }
  .cost { font-size: 12px; color: var(--accent); }
  .hint { font-size: 12px; opacity:.9; line-height: 1.4; border-top: 1px dashed #265c4a; padding-top: 8px; }
  .controls { display: grid; grid-auto-flow: column; gap: 8px; }
  .controls button {
    padding: 8px 12px; border: none; border-radius: 8px;
    background: var(--accent); color: #0f0f0f; font-weight: 700; cursor: pointer;
  }

  .game {
    position: relative; background: #174634; border: 1px solid var(--panel-border);
    border-radius: 10px; overflow: hidden; min-height: 60vh;
  }
  canvas { display: block; width: 100%; height: 100%; image-rendering: crisp-edges; touch-action: manipulation; }
  .overlay {
    position: absolute; inset: 12px 12px auto auto; background: rgba(0,0,0,0.25);
    border: 1px solid #265c4a; border-radius: 8px; padding: 8px 10px; font-size: 13px; pointer-events: none;
  }
  .bar { height: 8px; background: #0c1e19; border: 1px solid #113429; border-radius: 999px; overflow: hidden; }
  .bar > span { display: block; height: 100%; background: linear-gradient(90deg, #33d17a, #ffd54f); width: 0%; transition: width .2s ease; }

  @media (max-width: 860px) {
    .wrap { grid-template-columns: 1fr; }
    .controls { grid-auto-flow: row; }
  }
</style>
</head>
<body>
<div class="wrap">
  <aside class="sidebar">
    <div class="title">üå± Plants vs Zombies ‚Äî Endless</div>
    <div class="stats">
      <div class="stat"><b>M·∫∑t tr·ªùi:</b> <span id="sun">100</span></div>
      <div class="stat"><b>ƒêi·ªÉm:</b> <span id="score">0</span></div>
      <div class="stat"><b>C·∫•p:</b> <span id="level">1</span></div>
      <div class="stat"><b>Ti·∫øn ƒë·ªô:</b><div class="bar"><span id="progress"></span></div></div>
    </div>

    <div class="buttons" id="plantButtons"></div>

    <div class="controls">
      <button id="startWave">Start wave</button>
      <button id="restart">Restart</button>
    </div>

    <div class="hint">
      <b>C√°ch ch∆°i:</b><br>
      - Nh·∫•n Start ho·∫∑c Space ƒë·ªÉ b·∫Øt ƒë·∫ßu; Restart ho·∫∑c R ƒë·ªÉ ch∆°i l·∫°i.<br>
      - Ch·ªçn c√¢y, ch·∫°m/click √¥ l∆∞·ªõi ƒë·ªÉ tr·ªìng. Shift+click/chu·ªôt ph·∫£i ƒë·ªÉ th√°o (ho√†n 50%).<br>
      - Di chu·ªôt/ƒë∆∞a ng√≥n tay qua icon m·∫∑t tr·ªùi ƒë·ªÉ t·ª± nh·∫∑t (1 sun = 50).<br>
      - Ice Shooter l√†m ch·∫≠m; Potato Mine c·∫ßn k√≠ch ho·∫°t; Repeater b·∫Øn ƒë√¥i; Spikeweed l√†m s√°t th∆∞∆°ng khi zombie d·∫´m; Cherry Bomb n·ªï l·ªõn.<br>
      - Endless: c·ª© 3 c·∫•p c√≥ m·ªôt boss Giant r·∫•t tr√¢u, ti·∫øn ch·∫≠m, ƒë·∫≠p c√¢y m·∫°nh.
    </div>
  </aside>

  <main class="game">
    <canvas id="gameCanvas"></canvas>
    <div class="overlay" id="msg">Nh·∫•n Start/Space ƒë·ªÉ b·∫Øt ƒë·∫ßu wave</div>
  </main>
</div>

<script>
(() => {
  // Logical grid
  const ROWS = 8, COLS = 10;
  const CELL_W = 90, CELL_H = 80;
  const GRID_LEFT = 40, GRID_TOP = 40;
  const LOGICAL_W = GRID_LEFT + COLS * CELL_W + 60;
  const LOGICAL_H = GRID_TOP + ROWS * CELL_H + 60;

  // Canvas
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  function resizeCanvas() {
    const rect = canvas.parentElement.getBoundingClientRect();
    const scale = Math.min(rect.width / LOGICAL_W, rect.height / LOGICAL_H);
    canvas.width = LOGICAL_W; canvas.height = LOGICAL_H;
    canvas.style.width = (LOGICAL_W * scale) + 'px';
    canvas.style.height = (LOGICAL_H * scale) + 'px';
    canvas.style.maxWidth = '100%'; canvas.style.maxHeight = '100%';
  }
  window.addEventListener('resize', resizeCanvas); resizeCanvas();

  // UI
  const ui = {
    sun: document.getElementById('sun'),
    score: document.getElementById('score'),
    level: document.getElementById('level'),
    progress: document.getElementById('progress'),
    msg: document.getElementById('msg'),
    plantButtons: document.getElementById('plantButtons'),
    startWave: document.getElementById('startWave'),
    restart: document.getElementById('restart'),
  };

  // Config: plants
  const PLANTS = {
    peashooter: { name:'Peashooter', cost:100, hp:100, cooldown:1200, type:'attack' },
    sunflower:  { name:'Sunflower',  cost:50,  hp:100, cooldown:8000, type:'sun' },
    wallnut:    { name:'Wallnut',    cost:50,  hp:450, cooldown:0,    type:'block' },
    iceshooter: { name:'Ice Shooter',cost:125, hp:100, cooldown:1500, type:'ice' },
    repeater:   { name:'Repeater',   cost:200, hp:100, cooldown:1350, type:'attack2' }, // b·∫Øn 2 vi√™n
    spikeweed:  { name:'Spikeweed',  cost:100, hp:120, cooldown:0,    type:'trap', dps: 10 }, // s√°t th∆∞∆°ng khi d·∫´m
    potatomine: { name:'Potato Mine',cost:25,  hp:40,  cooldown:0,    type:'mine', armTime:12000, blastRadius:50, damage:9999 },
    cherrybomb: { name:'Cherry Bomb',cost:150, hp:1,   cooldown:0,    type:'bomb', blastRadius:85, damage:9999 } // ƒë·∫∑t l√† n·ªï sau ch√∫t delay
  };

  // Config: zombies
  const ZOMBIES = {
    basic:  { name:'Zombie', hp:100, speed:0.05 },
    cone:   { name:'Conehead', hp:210, speed:0.05, armor:'cone' },
    bucket: { name:'Buckethead', hp:320, speed:0.05, armor:'bucket' },
    rugby:  { name:'All-Star', hp:380, speed:0.1, armor:'helmet' },
    giant:  { name:'Giant', hp:1500, speed:0.03, armor:'giant' } // boss
  };

  // Endless wave tuning
  const BASE_SPAWN_EVERY = 3000; // ms
  const BASE_DURATION = 35000;   // ms
  function levelConfig(levelIndex) {
    const isBoss = (levelIndex + 1) % 3 === 0;
    const duration = BASE_DURATION + Math.min(12000, levelIndex * 1500);
    const spawnEvery = Math.max(1400, BASE_SPAWN_EVERY - Math.min(1200, levelIndex * 120));
    const pool = isBoss
      ? ['basic','cone','bucket','rugby','giant']
      : levelIndex < 2
        ? ['basic','basic','cone']
        : levelIndex < 5
          ? ['basic','cone','bucket']
          : ['basic','cone','bucket','rugby'];
    return { duration, spawnEvery, mix: pool, boss: isBoss };
  }

  // State
  const SUN_VALUE = 50; // 1 sun = 50 ti·ªÅn
  let selectedPlant = null;
  let sun = 1000;
  let score = 0;
  let levelIndex = 0;
  let waveActive = false;
  let running = true;

  const grid = Array.from({ length: ROWS }, () => Array.from({ length: COLS }, () => null));
  const bullets = [];
  const zombies = [];
  const suns = [];

  let lastTime = 0;
  let spawnTimer = 0;
  let levelTime = 0;
  let msgTimer = 0;
  let pendingCherry = []; // schedule cherry bomb detonations

  // UI plant buttons
  Object.entries(PLANTS).forEach(([key, conf]) => {
    const btn = document.createElement('div'); btn.className = 'btn';
    const iconDiv = document.createElement('div');
    iconDiv.style.width = '32px'; iconDiv.style.height = '32px'; iconDiv.style.borderRadius = '8px';
    iconDiv.style.border = '2px solid #195141';
    iconDiv.style.background = ({
      peashooter:'#1b8f5b', sunflower:'#ffd54f', wallnut:'#8b5a2b',
      iceshooter:'#6ec6ff', repeater:'#2bb673', spikeweed:'#9aa1a6',
      potatomine:'#a36f2c', cherrybomb:'#ff3b3b'
    })[key] || '#1b8f5b';
    const infoDiv = document.createElement('div');
    infoDiv.innerHTML = `<b>${conf.name}</b><br><span class="cost">Chi ph√≠: ${conf.cost}</span>`;
    const tail = document.createElement('div');
    tail.textContent = conf.type === 'sun' ? '‚òÄÔ∏è' :
                       conf.type === 'block' ? 'üß±' :
                       conf.type === 'ice' ? '‚ùÑÔ∏è' :
                       conf.type === 'mine' ? 'üí£' :
                       conf.type === 'bomb' ? 'üí•' :
                       conf.type === 'trap' ? 'üõë' : 'üü¢';
    btn.appendChild(iconDiv); btn.appendChild(infoDiv); btn.appendChild(tail);
    btn.addEventListener('click', () => {
      selectedPlant = key;
      document.querySelectorAll('.btn').forEach(x => x.classList.remove('active'));
      btn.classList.add('active');
      message(`ƒê√£ ch·ªçn: ${conf.name}`);
    });
    ui.plantButtons.appendChild(btn);
  });

  // Helpers
  function updateUI() { ui.sun.textContent = sun; ui.score.textContent = score; ui.level.textContent = levelIndex + 1; }
  function message(text, time = 1600) { ui.msg.textContent = text; ui.msg.style.opacity = 1; msgTimer = time; }
  function cellRect(r, c) {
    const x = GRID_LEFT + c * CELL_W;
    const y = GRID_TOP + r * CELL_H;
    return { x, y, w: CELL_W, h: CELL_H };
  }
  function pointToCell(x, y) {
    x -= GRID_LEFT; y -= GRID_TOP;
    if (x < 0 || y < 0) return null;
    const c = Math.floor(x / CELL_W);
    const r = Math.floor(y / CELL_H);
    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return null;
    return { r, c };
  }
  function randChoice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

  // Sun
  const SUN_RADIUS = 26;
  function addSun(x, y, value = SUN_VALUE) { suns.push({ x, y, r: SUN_RADIUS, value, vy: 0.06 + Math.random() * 0.04 }); }
  function drawSunIcon(s) {
    ctx.save(); ctx.translate(s.x, s.y);
    ctx.fillStyle = '#ffd54f'; ctx.strokeStyle = '#c49a22'; ctx.lineWidth = 2;
    // core
    ctx.beginPath(); ctx.arc(0, 0, s.r * 0.7, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
    // rays
    const rays = 10;
    for (let i = 0; i < rays; i++) {
      const ang = (i / rays) * Math.PI * 2;
      const rx = Math.cos(ang) * s.r, ry = Math.sin(ang) * s.r;
      ctx.beginPath(); ctx.moveTo(rx * 0.62, ry * 0.62); ctx.lineTo(rx, ry); ctx.stroke();
    }
    // glint
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath(); ctx.arc(-s.r*0.3, -s.r*0.3, s.r*0.24, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // Spawn zombies (endless + boss every 3rd level)
  function spawnZombie() {
    const lane = Math.floor(Math.random() * ROWS);
    const cfg = levelConfig(levelIndex);
    let zType = randChoice(cfg.mix);
    // make sure boss appears during boss levels sometimes
    if (cfg.boss && Math.random() < 0.25) zType = 'giant';
    const conf = ZOMBIES[zType];
    const sizeMult = zType === 'giant' ? 1.6 : 1.0;
    zombies.push({
      kind: zType, lane,
      x: GRID_LEFT + COLS * CELL_W + 40,
      y: GRID_TOP + lane * CELL_H + CELL_H / 2,
      w: 36 * sizeMult, h: 54 * sizeMult,
      hp: conf.hp, baseHP: conf.hp,
      speed: conf.speed,
      eating: false,
      slowFactor: 1.0,
      smashTimer: 0 // for boss smash
    });
  }

  // Input mapping
  function mapClientToCanvas(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = LOGICAL_W / rect.width;
    const scaleY = LOGICAL_H / rect.height;
    return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
  }

  canvas.addEventListener('contextmenu', e => e.preventDefault());

  // Mouse interactions
  canvas.addEventListener('mousedown', (e) => {
    const { x, y } = mapClientToCanvas(e.clientX, e.clientY);

    // auto collect sun
    for (let i = suns.length - 1; i >= 0; i--) {
      const s = suns[i]; const dx = x - s.x, dy = y - s.y;
      if (dx*dx + dy*dy <= s.r*s.r * 1.4) { sun += s.value; suns.splice(i, 1); updateUI(); return; }
    }

    const cell = pointToCell(x, y); if (!cell) return;

    // remove plant
    if (e.button === 2 || e.shiftKey) {
      const p = grid[cell.r][cell.c];
      if (p) {
        const refund = Math.floor(PLANTS[p.kind].cost * 0.5);
        sun += refund; grid[cell.r][cell.c] = null; updateUI();
        message(`Th√°o c√¢y, ho√†n ${refund} m·∫∑t tr·ªùi`);
      }
      return;
    }

    // place plant
    if (!selectedPlant) { message('Ch·ªçn lo·∫°i c√¢y tr∆∞·ªõc nh√©.'); return; }
    if (grid[cell.r][cell.c]) { message('√î n√†y ƒë√£ c√≥ c√¢y.'); return; }
    const conf = PLANTS[selectedPlant];
    if (sun < conf.cost) { message(`Kh√¥ng ƒë·ªß m·∫∑t tr·ªùi (${conf.cost} c·∫ßn).`); return; }
    sun -= conf.cost; updateUI();

    const plant = {
      kind: selectedPlant, hp: conf.hp, r: cell.r, c: cell.c,
      shootTimer: 0, sunTimer: 0, armed: conf.type === 'mine' ? false : undefined, armProgress: 0
    };

    // Cherry Bomb: schedule detonation shortly after plant
    if (selectedPlant === 'cherrybomb') {
      const { x: cx, y: cy } = cellRect(cell.r, cell.c);
      pendingCherry.push({ x: cx + CELL_W/2, y: cy + CELL_H/2, radius: conf.blastRadius, timer: 700, damage: conf.damage });
      // cherry is consumed immediately (does not persist)
      message('Cherry Bomb k√≠ch ho·∫°t!');
    } else {
      grid[cell.r][cell.c] = plant;
      message(`Tr·ªìng ${conf.name} th√†nh c√¥ng.`);
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    const { x, y } = mapClientToCanvas(e.clientX, e.clientY);
    for (let i = suns.length - 1; i >= 0; i--) {
      const s = suns[i]; const dx = x - s.x, dy = y - s.y;
      if (dx*dx + dy*dy <= s.r*s.r * 1.4) { sun += s.value; suns.splice(i, 1); updateUI(); }
    }
  });

  // Touch interactions
  canvas.addEventListener('touchstart', (e) => {
    const t = e.touches[0];
    const { x, y } = mapClientToCanvas(t.clientX, t.clientY);
    // collect sun
    for (let i = suns.length - 1; i >= 0; i--) {
      const s = suns[i]; const dx = x - s.x, dy = y - s.y;
      if (dx*dx + dy*dy <= s.r*s.r * 1.4) { sun += s.value; suns.splice(i, 1); updateUI(); return; }
    }
    // place plant
    const cell = pointToCell(x, y); if (!cell) return;
    if (!selectedPlant || grid[cell.r][cell.c]) return;
    const conf = PLANTS[selectedPlant]; if (sun < conf.cost) return;
    sun -= conf.cost; updateUI();
    if (selectedPlant === 'cherrybomb') {
      const { x: cx, y: cy } = cellRect(cell.r, cell.c);
      pendingCherry.push({ x: cx + CELL_W/2, y: cy + CELL_H/2, radius: conf.blastRadius, timer: 700, damage: conf.damage });
      message('Cherry Bomb k√≠ch ho·∫°t!');
    } else {
      grid[cell.r][cell.c] = { kind: selectedPlant, hp: conf.hp, r: cell.r, c: cell.c, shootTimer: 0, sunTimer: 0, armed: conf.type === 'mine' ? false : undefined, armProgress: 0 };
    }
  }, { passive: true });

  canvas.addEventListener('touchmove', (e) => {
    const t = e.touches[0];
    const { x, y } = mapClientToCanvas(t.clientX, t.clientY);
    for (let i = suns.length - 1; i >= 0; i--) {
      const s = suns[i]; const dx = x - s.x, dy = y - s.y;
      if (dx*dx + dy*dy <= s.r*s.r * 1.4) { sun += s.value; suns.splice(i, 1); updateUI(); }
    }
  }, { passive: true });

  // Drawing
  function drawGrid() {
    // lawn texture stripes + subtle shading
    ctx.fillStyle = '#16543f';
    ctx.fillRect(GRID_LEFT - 10, GRID_TOP - 10, COLS * CELL_W + 20, ROWS * CELL_H + 20);

    for (let r = 0; r < ROWS; r++) {
      const base = r % 2 === 0 ? '#1a694f' : '#1f7559';
      const grad = ctx.createLinearGradient(GRID_LEFT, GRID_TOP + r * CELL_H, GRID_LEFT, GRID_TOP + (r+1)*CELL_H);
      grad.addColorStop(0, base);
      grad.addColorStop(1, r % 2 === 0 ? '#1b6e53' : '#207a5c');
      ctx.fillStyle = grad;
      ctx.fillRect(GRID_LEFT, GRID_TOP + r * CELL_H, COLS * CELL_W, CELL_H);
    }
    ctx.strokeStyle = '#0e362a'; ctx.lineWidth = 2;
    for (let c = 0; c <= COLS; c++) {
      const x = GRID_LEFT + c * CELL_W;
      ctx.beginPath(); ctx.moveTo(x, GRID_TOP); ctx.lineTo(x, GRID_TOP + ROWS * CELL_H); ctx.stroke();
    }
    for (let r = 0; r <= ROWS; r++) {
      const y = GRID_TOP + r * CELL_H;
      ctx.beginPath(); ctx.moveTo(GRID_LEFT, y); ctx.lineTo(GRID_LEFT + COLS * CELL_W, y); ctx.stroke();
    }
  }

  function drawPlant(p) {
    const { x, y } = cellRect(p.r, p.c);
    const cx = x + CELL_W / 2, cy = y + CELL_H / 2;

    // HP bar
    ctx.fillStyle = '#0b1c16'; ctx.fillRect(x + 6, y + 6, CELL_W - 12, 5);
    const maxHp = PLANTS[p.kind].hp;
    ctx.fillStyle = '#33d17a'; ctx.fillRect(x + 6, y + 6, (CELL_W - 12) * Math.max(0, p.hp / maxHp), 5);

    // base shadow (removed cuz its ass üî•)
   // ctx.fillStyle = 'rgba(0,0,0,0.25)';
 //   ctx.beginPath(); ctx.ellipse(cx, y + CELL_H - 10, 18, 6, 0, 0, Math.PI * 2); ctx.fill();

    if (p.kind === 'peashooter') {
      const g = ctx.createRadialGradient(cx-4, cy-4, 2, cx, cy, 16);
      g.addColorStop(0, '#2fd384'); g.addColorStop(1, '#1b8f5b');
      ctx.fillStyle = g; ctx.strokeStyle = '#0a5a3a'; ctx.lineWidth = 2.5;
      ctx.beginPath(); ctx.arc(cx, cy, 15, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      // stem
      ctx.strokeStyle = '#0c6f48'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(cx-12, cy+10); ctx.lineTo(cx-12, cy+18); ctx.stroke();
    } else if (p.kind === 'wallnut') {
      const g = ctx.createLinearGradient(cx-16, cy-20, cx+16, cy+20);
      g.addColorStop(0, '#9c6a39'); g.addColorStop(1, '#7a4f28');
      ctx.fillStyle = g; ctx.strokeStyle = '#5a3a1d'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.roundRect(cx - 16, cy - 20, 32, 40, 9); ctx.fill(); ctx.stroke();
    } else if (p.kind === 'sunflower') {
      ctx.fillStyle = '#ffd54f';
      for (let i = 0; i < 10; i++) {
        const a = i * (Math.PI * 2 / 10);
        ctx.beginPath(); ctx.arc(cx + Math.cos(a) * 12, cy + Math.sin(a) * 12, 5, 0, Math.PI * 2); ctx.fill();
      }
      ctx.fillStyle = '#c49a22'; ctx.beginPath(); ctx.arc(cx, cy, 10, 0, Math.PI * 2); ctx.fill();
    } else if (p.kind === 'iceshooter') {
      const g = ctx.createRadialGradient(cx-3, cy-3, 2, cx, cy, 14);
      g.addColorStop(0, '#aee4ff'); g.addColorStop(1, '#6ec6ff');
      ctx.fillStyle = g; ctx.strokeStyle = '#3ea0de'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(cx, cy, 14, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      // icy leaves
      ctx.fillStyle = '#d7f0ff';
      ctx.beginPath(); ctx.ellipse(cx+9, cy-7, 5, 3, 0.4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(cx-9, cy+5, 5, 3, -0.6, 0, Math.PI*2); ctx.fill();
    } else if (p.kind === 'repeater') {
      const g = ctx.createRadialGradient(cx-4, cy-4, 2, cx, cy, 15);
      g.addColorStop(0, '#52e6a3'); g.addColorStop(1, '#2bb673');
      ctx.fillStyle = g; ctx.strokeStyle = '#198a58'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(cx-4, cy, 14, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      ctx.beginPath(); ctx.arc(cx+6, cy, 12, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
    } else if (p.kind === 'spikeweed') {
      // ground spikes
      ctx.fillStyle = '#9aa1a6';
      for (let i = -2; i <= 2; i++) {
        ctx.beginPath(); ctx.moveTo(cx + i*6, cy+10); ctx.lineTo(cx + i*6 + 4, cy+2); ctx.lineTo(cx + i*6 + 8, cy+10); ctx.closePath(); ctx.fill();
      }
      ctx.fillStyle = '#65707a'; ctx.beginPath(); ctx.roundRect(cx - 20, cy + 12, 40, 6, 3); ctx.fill();
    } else if (p.kind === 'potatomine') {
      const g = ctx.createLinearGradient(cx-14, cy-10, cx+14, cy+10);
      g.addColorStop(0, '#b27a3f'); g.addColorStop(1, '#8b5f2a');
      ctx.fillStyle = g; ctx.strokeStyle = '#754d1b'; ctx.lineWidth = 3;
      ctx.beginPath(); ctx.roundRect(cx - 14, cy - 10, 28, 20, 7); ctx.fill(); ctx.stroke();
      if (p.armed) {
        ctx.fillStyle = '#ff5c5c'; ctx.beginPath(); ctx.arc(cx, cy - 14, 4.5, 0, Math.PI * 2); ctx.fill();
      } else {
        ctx.fillStyle = '#ffd54f'; const prog = Math.min(1, p.armProgress);
        ctx.fillRect(cx - 14, cy + 12, 28 * prog, 4);
      }
    } else if (p.kind === 'cherrybomb') {
      // not drawn: consumed instantly; explosions drawn separately
    }
  }

  function drawBullet(b) {
    ctx.fillStyle = b.ice ? '#6ec6ff' : '#9be36b';
    ctx.strokeStyle = b.ice ? '#3ea0de' : '#6fb54b';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(b.x, b.y, 5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
    if (b.ice) { ctx.fillStyle = 'rgba(110,198,255,0.35)'; ctx.beginPath(); ctx.arc(b.x, b.y, 7, 0, Math.PI*2); ctx.fill(); }
  }

  function drawZombie(z) {
    // base body
    const bodyGrad = ctx.createLinearGradient(z.x - z.w/2, z.y - z.h/2, z.x + z.w/2, z.y + z.h/2);
    bodyGrad.addColorStop(0, '#8b5f77'); bodyGrad.addColorStop(1, '#6b4255');
    ctx.fillStyle = bodyGrad; ctx.strokeStyle = '#483243'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.roundRect(z.x - z.w/2, z.y - z.h/2, z.w, z.h, 8); ctx.fill(); ctx.stroke();
    // head
    ctx.fillStyle = '#b78ea5'; ctx.beginPath(); ctx.arc(z.x, z.y - z.h/2 - 9, 11, 0, Math.PI * 2); ctx.fill();

    // armor variants
    if (z.kind === 'cone') {
      ctx.fillStyle = '#ff7f27';
      ctx.beginPath();
      ctx.moveTo(z.x, z.y - z.h/2 - 20);
      ctx.lineTo(z.x - 11, z.y - z.h/2 - 5);
      ctx.lineTo(z.x + 11, z.y - z.h/2 - 5);
      ctx.closePath(); ctx.fill();
    } else if (z.kind === 'bucket') {
      ctx.fillStyle = '#9aa1a6'; ctx.beginPath(); ctx.roundRect(z.x - 13, z.y - z.h/2 - 20, 26, 14, 3); ctx.fill();
      ctx.fillStyle = '#848b90'; ctx.fillRect(z.x - 15, z.y - z.h/2 - 6, 30, 3);
    } else if (z.kind === 'rugby') {
      ctx.fillStyle = '#c62828'; ctx.beginPath(); ctx.arc(z.x, z.y - z.h/2 - 9, 12, 0, Math.PI * 2); ctx.fill();
      ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.moveTo(z.x - 7, z.y - z.h/2 - 9); ctx.lineTo(z.x + 7, z.y - z.h/2 - 9); ctx.stroke();
      ctx.fillStyle = '#d84315'; ctx.beginPath(); ctx.roundRect(z.x - z.w/2, z.y - z.h/2, z.w, 9, 4); ctx.fill();
    } else if (z.kind === 'giant') {
      // shoulder pads + giant club hint
      ctx.fillStyle = '#5d3b49'; ctx.beginPath(); ctx.roundRect(z.x - z.w/2, z.y - z.h/2, z.w, 12, 5); ctx.fill();
      ctx.fillStyle = '#3b2a33'; ctx.beginPath(); ctx.roundRect(z.x + z.w/2 - 8, z.y - 6, 16, 6, 3); ctx.fill();
    }

    // hp bar
    ctx.fillStyle = '#0b1c16'; ctx.fillRect(z.x - 20, z.y + z.h/2 + 4, 40, 6);
    ctx.fillStyle = '#ff5c5c'; ctx.fillRect(z.x - 20, z.y + z.h/2 + 4, 40 * Math.max(0, z.hp / z.baseHP), 6);

    // slow tint
    if (z.slowFactor < 1) {
      ctx.fillStyle = 'rgba(110,198,255,0.2)';
      ctx.beginPath(); ctx.roundRect(z.x - z.w/2, z.y - z.h/2, z.w, z.h, 8); ctx.fill();
    }
  }

  // Game loop logic
  function update(dt) {
    if (msgTimer > 0) { msgTimer -= dt; if (msgTimer <= 0) ui.msg.style.opacity = 0; }

    // ambient suns movement
    for (let i = suns.length - 1; i >= 0; i--) {
      const s = suns[i]; s.y += s.vy * dt;
      if (s.y > GRID_TOP + ROWS * CELL_H - 10) s.vy = 0;
    }

    const cfg = levelConfig(levelIndex);
    if (waveActive) {
      levelTime += dt; spawnTimer += dt;
      const progress = Math.min(1, levelTime / cfg.duration);
      ui.progress.style.width = (progress * 100).toFixed(1) + '%';

      if (spawnTimer >= cfg.spawnEvery) { spawnTimer = 0; spawnZombie(); }

      // level rollover (endless)
      if (progress >= 1 && zombies.length === 0) {
        levelIndex++; levelTime = 0; spawnTimer = 0; sun += SUN_VALUE; updateUI();
        const bossMsg = levelConfig(levelIndex-1).boss ? ' (Boss ƒë√£ b·ªã h·∫°!)' : '';
        message(`Qua c·∫•p ${levelIndex}${bossMsg}. Th∆∞·ªüng +${SUN_VALUE} m·∫∑t tr·ªùi.`);
      }
    }

    // pending cherry detonations
    for (let i = pendingCherry.length - 1; i >= 0; i--) {
      const ch = pendingCherry[i];
      ch.timer -= dt;
      if (ch.timer <= 0) {
        // damage all zombies in radius
        for (let j = zombies.length - 1; j >= 0; j--) {
          const z = zombies[j];
          const dx = z.x - ch.x, dy = z.y - ch.y;
          if (Math.hypot(dx, dy) <= ch.radius) {
            z.hp -= ch.damage;
            if (z.hp <= 0) { score += 10; addSun(z.x, z.y - 12); zombies.splice(j, 1); j--; updateUI(); }
          }
        }
        // explosion visual
        ctx.save();
        ctx.fillStyle = 'rgba(255,60,60,0.3)';
        ctx.beginPath(); ctx.arc(ch.x, ch.y, ch.radius, 0, Math.PI*2); ctx.fill();
        ctx.restore();
        pendingCherry.splice(i, 1);
      }
    }

    // plants behaviors
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const p = grid[r][c]; if (!p) continue;
        const conf = PLANTS[p.kind]; p.shootTimer += dt; p.sunTimer += dt;

        if (p.kind === 'sunflower') {
          if (p.sunTimer >= conf.cooldown) {
            p.sunTimer = 0;
            const { x, y } = cellRect(p.r, p.c); addSun(x + CELL_W/2, y + 16, SUN_VALUE);
          }
        } else if (p.kind === 'potatomine') {
          if (!p.armed) {
            p.armProgress = Math.min(1, p.sunTimer / conf.armTime);
            if (p.sunTimer >= conf.armTime) p.armed = true;
          } else {
            const cellX = GRID_LEFT + c * CELL_W + CELL_W/2;
            const cellY = GRID_TOP + r * CELL_H + CELL_H/2;
            let exploded = false;
            for (let i = zombies.length - 1; i >= 0; i--) {
              const z = zombies[i];
              const dx = z.x - cellX, dy = z.y - cellY;
              if (Math.hypot(dx, dy) <= conf.blastRadius) { exploded = true; break; }
            }
            if (exploded) {
              for (let j = zombies.length - 1; j >= 0; j--) {
                const z2 = zombies[j];
                const d2x = z2.x - cellX, d2y = z2.y - cellY;
                if (Math.hypot(d2x, d2y) <= conf.blastRadius + 8) {
                  z2.hp -= conf.damage;
                  if (z2.hp <= 0) { score += 10; addSun(z2.x, z2.y - 12); zombies.splice(j, 1); j--; updateUI(); }
                }
              }
              grid[r][c] = null;
            }
          }
        } else if (p.kind === 'spikeweed') {
          // damage any zombie overlapping this cell floor
          const cellX = GRID_LEFT + c * CELL_W + CELL_W/2;
          const cellY = GRID_TOP + r * CELL_H + CELL_H/2;
          zombies.forEach(z => {
            if (z.lane === r && Math.abs(z.x - cellX) < CELL_W/2) {
              z.hp -= conf.dps * (dt / 1000); // DPS
            }
          });
        } else if (p.kind === 'peashooter' || p.kind === 'iceshooter' || p.kind === 'repeater') {
          const ahead = zombies.some(z => z.lane === r && z.x > GRID_LEFT + c * CELL_W + CELL_W/2);
          if (ahead && p.shootTimer >= conf.cooldown) {
            p.shootTimer = 0;
            const { x, y } = cellRect(p.r, p.c);
            const base = { x: x + CELL_W - 8, y: y + CELL_H/2, vx: 0.36, dmg: 34, ice: false };
            if (p.kind === 'iceshooter') { base.dmg = 28; base.ice = true; }
            bullets.push({ ...base });
            if (p.kind === 'repeater') {
              bullets.push({ ...base, x: base.x + 8 }); // second shot slightly offset
            }
          }
        }
      }
    }

    // bullets move and collide
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i]; b.x += b.vx * dt;
      if (b.x > GRID_LEFT + COLS * CELL_W + 60) { bullets.splice(i, 1); continue; }
      for (let j = 0; j < zombies.length; j++) {
        const z = zombies[j];
        if (Math.abs(b.y - z.y) < z.h/2 && Math.abs(b.x - z.x) < z.w/2) {
          let dmg = b.dmg;
          if (z.kind === 'bucket') dmg *= 0.72;
          else if (z.kind === 'cone') dmg *= 0.85;
          else if (z.kind === 'rugby') dmg *= 0.75;
          else if (z.kind === 'giant') dmg *= 0.5;
          z.hp -= dmg;
          if (b.ice) z.slowFactor = Math.max(0.6, z.slowFactor * 0.85);
          bullets.splice(i, 1); break;
        }
      }
    }

    // zombies move/eat
    for (let i = zombies.length - 1; i >= 0; i--) {
      const z = zombies[i];
      const colIndex = Math.floor((z.x - GRID_LEFT) / CELL_W);
      const r = z.lane;
      const blockingPlant = (colIndex >= 0 && colIndex < COLS) ? grid[r][colIndex] : null;

      if (blockingPlant && blockingPlant.kind !== 'sunflower' && blockingPlant.kind !== 'spikeweed') {
        const eatDps = z.kind === 'rugby' ? 22 : z.kind === 'giant' ? 32 : 18;
        blockingPlant.hp -= eatDps * (dt / 600);
        if (blockingPlant.hp <= 0) grid[r][colIndex] = null;

        // giant smash: periodically destroy plant in front
        if (z.kind === 'giant') {
          z.smashTimer += dt;
          if (z.smashTimer >= 900) {
            z.smashTimer = 0;
            if (blockingPlant) { grid[r][colIndex] = null; }
          }
        }
      } else {
        const speed = z.speed * z.slowFactor;
        z.x -= speed * dt;
      }

      if (z.hp <= 0) { score += 10; addSun(z.x, z.y - 12); zombies.splice(i, 1); updateUI(); continue; }
      if (z.x < GRID_LEFT - 8) { running = false; message('B·∫°n ƒë√£ thua! Zombie ƒë√£ v√†o nh√†. Nh·∫•n Restart/R ƒë·ªÉ ch∆°i l·∫°i.'); }
    }
  }

  function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawGrid();

    // plants
    for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) { const p = grid[r][c]; if (p) drawPlant(p); }

    // bullets
    bullets.forEach(drawBullet);

    // zombies
    zombies.forEach(drawZombie);

    // suns
    suns.forEach(drawSunIcon);

    // cherry pending subtle glow (optional)
    pendingCherry.forEach(ch => {
      ctx.fillStyle = 'rgba(255,60,60,0.15)';
      ctx.beginPath(); ctx.arc(ch.x, ch.y, ch.radius * 0.7, 0, Math.PI*2); ctx.fill();
    });
  }

  function loop(ts) {
    if (!lastTime) lastTime = ts;
    const dt = ts - lastTime; lastTime = ts;
    if (running) { update(dt); render(); requestAnimationFrame(loop); } else { render(); }
  }

  // Restart
  function resetGame() {
    for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) grid[r][c] = null;
    bullets.length = 0; zombies.length = 0; suns.length = 0; pendingCherry.length = 0;
    selectedPlant = null;
    document.querySelectorAll('.btn').forEach(x => x.classList.remove('active'));
    sun = 100; score = 0; levelIndex = 0; spawnTimer = 0; levelTime = 0; waveActive = false; running = true; msgTimer = 0;
    ui.msg.style.opacity = 1; ui.msg.textContent = 'Nh·∫•n Start/Space ƒë·ªÉ b·∫Øt ƒë·∫ßu wave';
    ui.progress.style.width = '0%'; updateUI(); lastTime = 0;
    requestAnimationFrame(loop);
  }

  // Controls
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') { if (!waveActive && running) { waveActive = true; message('Wave b·∫Øt ƒë·∫ßu!'); } }
    if (e.key.toLowerCase() === 'r') resetGame();
  });
  ui.startWave.addEventListener('click', () => { if (!waveActive && running) { waveActive = true; message('Wave b·∫Øt ƒë·∫ßu!'); } });
  ui.restart.addEventListener('click', resetGame);

  // Ambient suns
  setInterval(() => {
    const x = GRID_LEFT + 20 + Math.random() * (COLS * CELL_W - 40);
    const y = GRID_TOP + 20 + Math.random() * (ROWS * CELL_H - 40);
    addSun(x, y, SUN_VALUE);
  }, 5200);

  // Init
  updateUI();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
